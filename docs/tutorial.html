

<!doctype html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tutorial &#8212; Alibaba Cloud Quantum Development Platform 0.1 documentation</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Tensor network and its contractions" href="tensor_network.html" />
    <link rel="prev" title="Overview" href="installation.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tensor_network.html" title="Tensor network and its contractions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Overview"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Alibaba Cloud Quantum Development Platform 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Tutorial</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<p>In the tutorial, we will show you two examples of using <cite>ACQDP</cite>. The first one is to use the tensor network functionalities to experiment with tensor network states. The second one is to use the circuit library to experiment with the fidelity of GHZ states under various noise models.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#mps-state" id="id1">MPS State</a></p></li>
<li><p><a class="reference internal" href="#ghz-state" id="id2">GHZ State</a></p></li>
</ul>
</div>
<div class="section" id="mps-state">
<h2>MPS State<a class="headerlink" href="#mps-state" title="Permalink to this headline">¶</a></h2>
<p>In this section, we create two random ring-MPS states and calculate their fidelity.</p>
<p>An MPS state is a quantum state formulated as a centipede-shaped tensor network. We first define a random MPS state on a ring, with bond dimension and number of qubits given as the input:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">acqdp.tensor_network</span> <span class="kn">import</span> <span class="n">TensorNetwork</span><span class="p">,</span> <span class="n">normalize</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="k">def</span> <span class="nf">MPS</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">,</span> <span class="n">bond_dim</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">):</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">bond_dim</span><span class="p">,</span> <span class="n">bond_dim</span><span class="p">))</span> <span class="o">+</span>\
                    <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">bond_dim</span><span class="p">,</span> <span class="n">bond_dim</span><span class="p">))</span>
        <span class="n">a</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">),</span> <span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_qubits</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">)],</span> <span class="n">tensor</span><span class="o">=</span><span class="n">tensor</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">open_edge</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>This constructs an MPS state of the following form, where the internal connections <cite>(i, ‘i’)</cite> have bond dimension <cite>bond_dim</cite> and the outgoing wires <cite>(i, ‘o’)</cite> have bond dimension 2 representing a qubit system.</p>
<a class="reference internal image-reference" href="_images/MPS.pdf"><img alt="An illustration of a ring-MPS state" src="_images/MPS.pdf" style="width: 700px;" /></a>
<p>Note that normalize() computes the frobenius norm of the tensor network, which already involves tensor network contraction.</p>
<p>For a further break down, in the code we first defined a tensor network:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">()</span>
</pre></div>
</div>
<p>Each tensor <cite>i</cite> is of shape <cite>(2, bond_dim, bond_dim)</cite>. We add the tensor into the tensor network by specifying its connection in the tensor network:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">),</span> <span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_qubits</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">)],</span> <span class="n">tensor</span><span class="o">=</span><span class="n">tensor</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, the outgoing edges <cite>[(i, ‘o’)]</cite> needs to be opened:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">open_edge</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>This allows us to get two random MPS states:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">MPS</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">MPS</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>To calculate the fidelity of the two states, we put them into a single tensor network representing their inner product:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="o">~</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, The tensor network <cite>c</cite> is constructed by adding the two tensor valued objects <cite>a</cite> and <cite>~b</cite> into the tensor network. The outgoing edges of <cite>a</cite> are identified as 0 to 9 in <cite>c</cite>, and that matches the outgoing edges of <cite>b</cite>. As no open edges is indicated in <cite>c</cite>, it sums over all the indices 0 to 9 and yield the inner product of <cite>a</cite> and <cite>b</cite>. (Note that the complex conjugate of b is added instead of b itself.)</p>
<p>This tensor network <cite>c</cite> takes two tensor valued objects <cite>a</cite> and <cite>b</cite> which are not necessarily tensors. This is a feature of the ACQDP: components in tensor networks do not have to be tensors, which allows nested structures of tensor networks to be easily constructed. The fidelity is then the absolute value of the inner product:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fidelity = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">contract</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="ghz-state">
<h2>GHZ State<a class="headerlink" href="#ghz-state" title="Permalink to this headline">¶</a></h2>
<p>The next example features our circuit module, which allows simulation of quantum computation supported by the powerful tensor network engine. A priliminary noise model is also included.</p>
<p>A <span class="math notranslate nohighlight">\(n\)</span>-qubit GHZ state, also known as “Schroedinger cat states” or just “cat states”, are defined as <span class="math notranslate nohighlight">\(\frac{1}{\sqrt2}\left(|0\rangle^{\otimes n}+|1\rangle^{\otimes n}\right)\)</span>. A <span class="math notranslate nohighlight">\(n\)</span>-qubit GHZ state can be prepared by setting the first qubit <span class="math notranslate nohighlight">\(|+\rangle\)</span>, and apply CNOT gate sequentially from the first qubit to all the other qubits. In ACQDP, we first define the circuit preparing the GHZ state:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">acqdp.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">HGate</span><span class="p">,</span> <span class="n">CNOTGate</span><span class="p">,</span> <span class="n">ZeroState</span>

<span class="k">def</span> <span class="nf">GHZState</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ZeroState</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HGate</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ZeroState</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CNOTGate</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">a</span>
</pre></div>
</div>
<p>A GHZ state then can be constructed upon calling <span class="math notranslate nohighlight">\(GHZState(n)\)</span>. A 4-qubit GHZ state is then</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">GHZState</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p><cite>a</cite> is right now a syntactic representation of the GHZ state as a gate sequence. To examine the state as a tensor representing the pure state vector,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a_tensor</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">tensor_pure</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a_tensor</span><span class="o">.</span><span class="n">contract</span><span class="p">())</span>
</pre></div>
</div>
<p>gives the output</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([[[[</span><span class="mf">0.70710678</span><span class="p">,</span> <span class="mf">0.</span>        <span class="p">],</span>
        <span class="p">[</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">]],</span>

        <span class="p">[[</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">],</span>
        <span class="p">[</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">]]],</span>


      <span class="p">[[[</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">],</span>
        <span class="p">[</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">]],</span>

        <span class="p">[[</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">],</span>
        <span class="p">[</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.70710678</span><span class="p">]]]])</span><span class="o">.</span>
</pre></div>
</div>
<p>The <cite>tensor_pure</cite> of a circuit object returns the tensor network representing it as a pure operation, i.e. a state vector, an isometry, or a projective measurement. In this case we do get the state vector; the density matrix will be returned if we choose to contract the <cite>tensor_density</cite>.</p>
<p>We are now interested in how the fidelity is preserved under simplified noise models.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">acqdp.circuit</span> <span class="kn">import</span> <span class="n">add_noise</span><span class="p">,</span> <span class="n">Depolarization</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">add_noise</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Depolarization</span><span class="p">(</span><span class="mf">0.01</span><span class="p">))</span>
</pre></div>
</div>
<p>The quantum state <cite>b</cite> representing noisy preparation of the GHZ state is no longer pure. To compute the fidelity of <cite>b</cite> and <cite>a</cite>, we compute the probability of postselecting <cite>b</cite> on the state <cite>a</cite>, i.e. concatenate <cite>b</cite> with <cite>~a</cite>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">|</span> <span class="o">~</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">tensor_density</span><span class="o">.</span><span class="n">contract</span><span class="p">())</span>
</pre></div>
</div>
<p>which gives the result <cite>0.7572548016539656</cite>.</p>
<p>The landscape of the fidelity with respect to the depolarization strength is given in the following figure:</p>
<p>(<a class="reference external" href=".//tutorial-1.py">Source code</a>, <a class="reference external" href=".//tutorial-1.png">png</a>, <a class="reference external" href=".//tutorial-1.hires.png">hires.png</a>, <a class="reference external" href=".//tutorial-1.pdf">pdf</a>)</p>
<div class="figure align-default">
<img alt="_images/tutorial-1.png" src="_images/tutorial-1.png" />
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tutorial</a><ul>
<li><a class="reference internal" href="#mps-state">MPS State</a></li>
<li><a class="reference internal" href="#ghz-state">GHZ State</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="installation.html"
                        title="previous chapter">Overview</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tensor_network.html"
                        title="next chapter">Tensor network and its contractions</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script><h3>See Also</h3>
<ul>
<li><a href="https://github.com/alibaba/acqdp">Source code on Github</a></li>
<li><a href="https://pypi.org/project/acqdp/">PyPI Project</a></li>
</ul>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tensor_network.html" title="Tensor network and its contractions"
             >next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Overview"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Alibaba Cloud Quantum Development Platform 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Tutorial</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Alibaba Quantum Laboratory.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>