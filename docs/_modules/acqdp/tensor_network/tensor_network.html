

<!doctype html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>acqdp.tensor_network.tensor_network &#8212; Alibaba Cloud Quantum Development Platform 0.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Alibaba Cloud Quantum Development Platform 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">acqdp.tensor_network.tensor_network</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for acqdp.tensor_network.tensor_network</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">networkx</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">.tensor_valued</span> <span class="kn">import</span> <span class="n">TensorValued</span><span class="p">,</span> <span class="n">DTYPE</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">opt_einsum</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">acqdp.utility</span> <span class="kn">import</span> <span class="n">opt_einsum_ext</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cmp_to_key</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="n">THIS_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>

<div class="viewcode-block" id="TensorNetwork"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork">[docs]</a><span class="k">class</span> <span class="nc">TensorNetwork</span><span class="p">(</span><span class="n">TensorValued</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`TensorNetwork` is a collection of :class:`Tensor`, with indices from different tensors identified and summed up to present a new tensor. An example of tensor network is two 2-tensors with a common edge representing the matrix multiplication. A :class:`TensorNetwork` is a graphical representation of an Einstein summation.</span>

<span class="sd">    :ivar network: attributed :class:`networkx.Graph` object, representing the attributed hypergraph of the tensor network as a tanner graph.</span>
<span class="sd">    :ivar dtype: dtype of the :class:`TensorValued` object.</span>
<span class="sd">    :ivar open_edges: a list of edge names, indicating the outgoing wires of the tensor network.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">open_edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dtype</span><span class="p">:</span> <span class="nb">type</span> <span class="o">=</span> <span class="n">DTYPE</span><span class="p">,</span>
                 <span class="n">bond_dim</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of :class:`TensorNetwork` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">open_edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">open_edges</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">open_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">bond_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_signature</span><span class="p">()</span>

<div class="viewcode-block" id="TensorNetwork.contract"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.contract">[docs]</a>    <span class="k">def</span> <span class="nf">contract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the :class:`TensorNetwork` object as an :class:`numpy.ndarray`.</span>

<span class="sd">        :param preset: Select a preset mode. If set to `default`, will contract the tensor network with default ordering and no post-processing. If set to `khp`, will invoke advanced KaHyPar-based contraction order finding routine. If set to `None`, will read config file or input keyword arguments for order finding specifications.</span>
<span class="sd">        :type preset: `&quot;default&quot;`, `&quot;khp&quot;` or `None`.</span>
<span class="sd">        :param config: File name for the config file. If preset option is not given and config file is given, the keyword arguments will be ignored and the specification will be read from the config file.</span>
<span class="sd">        :type config: `str`</span>
<span class="sd">        :param kwargs: If neither the preset option nor the config file name is given, the program will read the keyword arguments for order finding specifications. See :class:`OrderFinder`, :class:`Compiler`, :class:`Contractor` for individual specifications.</span>
<span class="sd">        :type kwargs: `dict`</span>

<span class="sd">        :returns: :class:`numpy.ndarray`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">preset</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="n">config</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">THIS_DIR</span><span class="p">,</span> <span class="s1">&#39;default_params.json&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">preset</span> <span class="o">==</span> <span class="s1">&#39;khp&#39;</span><span class="p">:</span>
            <span class="n">config</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">THIS_DIR</span><span class="p">,</span> <span class="s1">&#39;khp_params.json&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">preset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid preset options&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">config</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find_order</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="TensorNetwork.find_order"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.find_order">[docs]</a>    <span class="k">def</span> <span class="nf">find_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a contraction scheme of the :class:`TensorNetwork` object. Equivalent to `next(get_order_finder(**kwargs).find_order(self))`. See :meth:`OrderFinder.find_order`.</span>


<span class="sd">        :param input_file: Input file name. When given, load the contraction scheme from the input file.</span>
<span class="sd">        :type input_file: str, optional</span>
<span class="sd">        :param output_file: Output file name. When given, the contraction scheme found will be dumped into the file.</span>
<span class="sd">        :type output_file: str, optional</span>
<span class="sd">        :returns: :class:`ContractionScheme`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">acqdp.tensor_network</span> <span class="kn">import</span> <span class="n">ContractionScheme</span>
        <span class="k">if</span> <span class="n">input_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">input_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ContractionScheme</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Order file not found. Proceed to order finding procedure&#39;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">acqdp.tensor_network.order_finder</span> <span class="kn">import</span> <span class="n">get_order_finder</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">get_order_finder</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">find_order</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">output_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Order result saved at &quot;</span><span class="o">+</span> <span class="n">output_file</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="TensorNetwork.compile"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.compile">[docs]</a>    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile a :class:`ContractionScheme` corresponding to the :class:`TensorNetwork` object into a runtime executable contraction process as a :class:`ContractionTask`. Equivalent to `Compiler(**kwargs.get(&#39;compiler_params&#39;, {})).compile(self, order)` (See :meth:`Compiler.compile`).</span>

<span class="sd">        :returns: :class:`ContractionTask`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">acqdp.tensor_network.compiler</span> <span class="kn">import</span> <span class="n">Compiler</span>
        <span class="k">return</span> <span class="n">Compiler</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;compiler_params&#39;</span><span class="p">,</span> <span class="p">{}))</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">refresh_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signature</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">d</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">})</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">d</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">})</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The common property of all :class:`TensorValued` classes, yielding the shape of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">)][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nodes_str</span> <span class="o">=</span> <span class="s2">&quot;Nodes: </span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">nodes_str</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span>\
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;tensor&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>\
                <span class="o">+</span> <span class="s2">&quot;connected to: &quot;</span>\
                <span class="o">+</span> <span class="nb">str</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">node</span><span class="p">]])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">edges_str</span> <span class="o">=</span> <span class="s2">&quot;Edges: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges_by_name</span><span class="p">)</span>
        <span class="n">open_str</span> <span class="o">=</span> <span class="s2">&quot;Open edges: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>\
            <span class="o">+</span> <span class="n">nodes_str</span>\
            <span class="o">+</span> <span class="n">edges_str</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>\
            <span class="o">+</span> <span class="n">open_str</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The common property of all :class:`TensorValued` classes, indicating whether the :class:`TensorValued` object is valid or not.</span>
<span class="sd">        In every step of a program, all existing :class:`TensorValued` object must be valid, otherwise an exception should be thrown out;</span>
<span class="sd">        this property is for double checking that the current :class:`TensorValued` object is indeed valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;tensor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">lst</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>\
                   <span class="ow">and</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>\
                   <span class="ow">and</span> <span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_ready</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The common property of all :class:`TensorValued` classes, indicating whether the current :class:`TensorValued` object is ready for</span>
<span class="sd">        contraction, i.e. whether it semantically represents a tensor with a definite value.</span>
<span class="sd">        In the process of a program, not all :class:`TensorValued` objects need to be ready; however once the `data` property of a certain object is queried,</span>
<span class="sd">        such object must be ready in order to successfully yield an :class:`numpy.ndarray` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">tsr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;tensor&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">tsr</span><span class="o">.</span><span class="n">is_ready</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">node</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">tsr</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">closed_edges_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of closed edge names, i.e., edges that do not appear in the open edges.</span>
<span class="sd">        :returns: :class:`Set` -- The set of closed edge names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges_by_name</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">edges_by_name_from_nodes_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of all edges connected to any of the input nodes.</span>

<span class="sd">        :param node_names: a set of nodes in this tensor network.</span>
<span class="sd">        :type node_names: :class:`List`.</span>

<span class="sd">        :returns: :class:`Set` -- the set of edges who is connected to some node in the set `nodes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">node_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_name</span>
        <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)])</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">res</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">closed_edges_by_name_from_nodes_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of all closed edges connected to any of the input nodes.</span>

<span class="sd">        :param node_names: a set of nodes in this tensor network.</span>
<span class="sd">        :type node_names: :class:`List`.</span>

<span class="sd">        :returns: :class:`Set` -- the set of closed edges who is connected to some node in the set `nodes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_by_name_from_nodes_by_name</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">edge_name</span> <span class="k">for</span> <span class="n">edge_name</span> <span class="ow">in</span> <span class="n">edges</span> <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)])</span><span class="o">.</span><span class="n">issubset</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">])</span>
                <span class="ow">and</span> <span class="n">edge_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">nodes_by_name_from_edges_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of all nodes connected to the set of input edges.</span>

<span class="sd">        :param edge_names: a list of edges in this tensor network.</span>
<span class="sd">        :type edge_names: :class:`List`</span>

<span class="sd">        :returns: :class:`Set` -- the set of nodes who are connected to some node in the set `edges`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">edge_name</span> <span class="ow">in</span> <span class="n">edge_names</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)])</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">res</span><span class="p">])</span>

    <span class="c1"># tensor network manipulations</span>

    <span class="k">def</span> <span class="nf">add_attribute_to_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an attribute to all the names for nodes and edges of a tensor network.</span>

<span class="sd">        :param name: The attribute to be added to all the names.</span>
<span class="sd">        :type name: :class:`Tuple` or hashable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">comb_name</span><span class="p">(</span><span class="n">att</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">att</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span> <span class="n">att</span> <span class="o">=</span> <span class="p">(</span><span class="n">att</span><span class="p">,)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span> <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">att</span> <span class="o">+</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">comb_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">},</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">comb_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">comb_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;edges&#39;</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">update_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dic</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the dimension of the edges in the tensor network.</span>

<span class="sd">        :param dic: the key-value pairs of the edges to be updated. The keys are the name of the edges; the values are the corresponding updated bond dimensions. If a value is -1, that edge will be updated as a wildcard-dimensional edge, meaning that it will be automatically set a bond dimension when connected to tensor-valued objects with a definite dimension.</span>
<span class="sd">        :type dic: :class:`Dict`</span>
<span class="sd">        :raises: AssertionError -- An error will be raised when the dimension update results in inconsistent bond dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">edge_name</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edge </span><span class="si">{}</span><span class="s2"> does not exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edge_name</span><span class="p">))</span>
            <span class="n">edge_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)]</span>
            <span class="n">edge_dim</span> <span class="o">=</span> <span class="n">edge_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dim&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">edge_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edge_data</span><span class="p">[</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="n">edge_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dic</span><span class="p">[</span><span class="n">edge_name</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">edge_dim</span> <span class="o">==</span> <span class="n">dic</span><span class="p">[</span><span class="n">edge_name</span><span class="p">],</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edge_name</span><span class="p">,</span>
                                                                             <span class="n">dic</span><span class="p">[</span><span class="n">edge_name</span><span class="p">],</span>
                                                                             <span class="n">edge_dim</span><span class="p">)</span>

<div class="viewcode-block" id="TensorNetwork.add_node"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_open</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a node into the tensor network.</span>

<span class="sd">        :param node_name: The name of the node to be added. If not provided, a new name will be assigned.</span>
<span class="sd">        :type node_name: :class:`hashable`</span>
<span class="sd">        :param edges: The edges the new tensor node is being connected to.</span>
<span class="sd">        :type edges: :class:`List` -- list of edges in the tensor network corresponding to the open edges of the new node. If not given, defaults to edges `[0, ..., len(shape)]`</span>
<span class="sd">        :param tensor: The value of the newly added tensor.</span>
<span class="sd">        :type tensor: :class:`tensor_network.tensor_valued.TensorValued`.</span>
<span class="sd">        :param is_open: Whether the new indices associated to the new node will be added to open_edges.</span>
<span class="sd">        :type is_open: :class:`bool`</span>
<span class="sd">        :returns: hashable -- Name of the node added. If none is given as input, return the one automatically signed.</span>
<span class="sd">        :raises: ValueError -- An existing node in the tensor network is being added.</span>
<span class="sd">        :raises: IndexError -- A node is added with ambiguous connection to the tensor network. Happens when neither the shape of the tensor nor the connecting edges are given.</span>
<span class="sd">        :raises: AssertionError -- A mismatch in the bond dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.tensor</span> <span class="kn">import</span> <span class="n">Tensor</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> already exists in the tensor network&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">TensorValued</span><span class="p">):</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">complex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">complex</span>
        <span class="k">if</span> <span class="n">node_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_name</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">identifier</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Connection is ambiguous&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">add_node</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">),</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="n">bond_dim</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bond_dim</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge_name</span><span class="p">,</span> <span class="n">bond_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([((</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">))</span> <span class="k">for</span> <span class="n">edge_name</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_node</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">tensor</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_open</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">open_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_signature</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">node_name</span></div>

<div class="viewcode-block" id="TensorNetwork.pop_node"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.pop_node">[docs]</a>    <span class="k">def</span> <span class="nf">pop_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop a tensor node from the tensor network. This operation simply removes the node from the hypergraph.</span>

<span class="sd">        :returns: dict -- The dict containing all the information of the popped node, including its tensor and hyperedge connections.</span>

<span class="sd">        :param node_name: Name of the node to be popped.</span>
<span class="sd">        :type node_name: hashable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">remove_node</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_signature</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pop</span></div>

<div class="viewcode-block" id="TensorNetwork.remove_node"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.remove_node">[docs]</a>    <span class="k">def</span> <span class="nf">remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a tensor node from the tensor network. The difference between removing a node and popping anode is that popping a node does not change the</span>
<span class="sd">        output shape of the tensor network, while removing a node would result in a new tensor-valued object, where all edges connected to the removed node</span>
<span class="sd">        are appended to the end of the open edges list.</span>

<span class="sd">        :returns: dict -- The dict containing all the information of the removed node, including its tensor and hyperedge connections.</span>
<span class="sd">        :param node_name: Name of the node to be removed.</span>
<span class="sd">        :type node_name: hashable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_node</span><span class="p">(</span><span class="n">node_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span> <span class="o">+=</span> <span class="n">pop</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pop</span></div>

<div class="viewcode-block" id="TensorNetwork.update_node"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.update_node">[docs]</a>    <span class="k">def</span> <span class="nf">update_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update an existing node of the tensor network by another tensor-valued object.</span>

<span class="sd">        :param node_name: Name of the node to be updated.</span>
<span class="sd">        :type node_name: hashable</span>
<span class="sd">        :param tensor: The new tensor to be put at the node. If `None`, the tensor must be updated with an actual value later in order for the tensor network to be ready for contraction.</span>
<span class="sd">        :type tensor: :class:`TensorValued` or `None`</span>
<span class="sd">        :raises: AssertionError -- Node update results in a bond dimension mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.tensor</span> <span class="kn">import</span> <span class="n">Tensor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">TensorValued</span><span class="p">):</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">complex</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">complex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">complex</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">refresh_signature</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)][</span><span class="s1">&#39;tensor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_dimension</span><span class="p">({</span><span class="n">edge</span><span class="p">:</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)][</span><span class="s1">&#39;edges&#39;</span><span class="p">])})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_dimension</span><span class="p">({</span><span class="n">edge</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)][</span><span class="s1">&#39;edges&#39;</span><span class="p">]})</span></div>

<div class="viewcode-block" id="TensorNetwork.add_edge"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bond_dim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate an index which is not in this tensor network before.</span>

<span class="sd">        :param edge_name: Name of the edge to be added. Will be automatically assigned if none is given.</span>
<span class="sd">        :type edge_name: hashable</span>
<span class="sd">        :param bond_dim: Bond dimension of the edge. If set to `None`, the edge bond dimension will be wildcard until set otherwise.</span>
<span class="sd">        :type bond_dim: `int` or `None`</span>

<span class="sd">        :returns: hashable -- Name of the newly added edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edge_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">edge_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">add_node</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="n">bond_dim</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bond_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_dimension</span><span class="p">({</span><span class="n">edge_name</span><span class="p">:</span> <span class="n">bond_dim</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">edge_name</span></div>

<div class="viewcode-block" id="TensorNetwork.open_edge"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.open_edge">[docs]</a>    <span class="k">def</span> <span class="nf">open_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bond_dim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append an edge to the list of open edges. If the edge does not exist, it will be created.</span>

<span class="sd">        :param edge_name: Name of the edge to be opened.</span>
<span class="sd">        :type edge_name: hashable</span>
<span class="sd">        :param bond_dim: Bond dimension of the edge. See `add_edge`.</span>
<span class="sd">        :type bond_dim: `int`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edge_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_by_name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge_name</span><span class="p">,</span> <span class="n">bond_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_signature</span><span class="p">()</span></div>

<div class="viewcode-block" id="TensorNetwork.close_edge"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.close_edge">[docs]</a>    <span class="k">def</span> <span class="nf">close_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make an edge closed. All appearances of the edge will be removed from the open edges list.</span>

<span class="sd">        :param edge_name: Edge to be closed.</span>
<span class="sd">        :type edge_name: hashable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">edge_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_signature</span><span class="p">()</span></div>

<div class="viewcode-block" id="TensorNetwork.fix_edge"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.fix_edge">[docs]</a>    <span class="k">def</span> <span class="nf">fix_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">,</span> <span class="n">fix_to</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">change_fix</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix an edge to a fixed value. The tensor network structure is not yet modified; this method only puts an attribute to the fixed hyperedges. The structure will be changed upon calling the `fix` method.</span>

<span class="sd">        :param edge_name: Edge to be fixed to a specific value.</span>
<span class="sd">        :type edge_name: hashable</span>
<span class="sd">        :param fix_to: the value the edge is fixed to. Should be an integer ranging from 0 to `bond_dim - 1`.</span>
<span class="sd">        :type fix_to: `int`</span>
<span class="sd">        :param change_fix: Mode of `fix_edge`. If `change_fix` is set to `True`, the edge will be fixed to the given value regardless of how it is fixed previously. If set to `False`, the fix will apply together with the previous fix, resulting in a zero tensor if the two fixes do not match.</span>
<span class="sd">        :type change_fix: `bool`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fix_to</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">fix_to</span> <span class="o">=</span> <span class="p">{</span><span class="n">fix_to</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fix_to</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fix_to</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">fix_to</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)][</span><span class="s1">&#39;dim&#39;</span><span class="p">])),</span> <span class="sa">f</span><span class="s2">&quot;Invalid operation: edge being fixed to invalid value </span><span class="si">{</span><span class="n">fix_to</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;fix_to&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">change_fix</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)][</span><span class="s1">&#39;fix_to&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)][</span><span class="s1">&#39;fix_to&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">fix_to</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)][</span><span class="s1">&#39;fix_to&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fix_to</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)][</span><span class="s1">&#39;fix_to&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fix_to</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">change_fix</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refresh_signature</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">fix_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fix_to</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix one outgoing index of the tensor network (see :class:`tensor_network.tensor_valued.TensorValued`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fix_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">fix_to</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_signature</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix the tensor network, by removing all hyperedges attributed to a fixed value. This operation changes the structure of the tensor network without changing the value of the tensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;fix_to&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_name_from_edges_by_name</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)][</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)][</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">([(</span><span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">e</span><span class="p">]])</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">complete_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Complete the tensor network by adding necessary delta tensors to the tensor network. This is in order to resolve the issue that repeated or new indices appear in the open edges, which is not yet recognized by Einstein summation conventions. This operation changes the structure of the tensor network without changing its value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;*&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_name</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="n">open_edge_names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_by_name_from_nodes_by_name</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">id_node</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="p">[],</span> <span class="n">id_node</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">open_edge_names</span><span class="p">:</span>
                <span class="n">open_edge_names</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">edge</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">open_edge_names</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">new_node</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">)][</span><span class="s1">&#39;dim&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">((</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">open_edge_names</span><span class="p">[</span><span class="n">edge</span><span class="p">]),</span>
                            <span class="p">[</span><span class="n">edge</span><span class="p">,</span> <span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">open_edge_names</span><span class="p">[</span><span class="n">edge</span><span class="p">])],</span> <span class="n">new_node</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">open_edge_names</span><span class="p">[</span><span class="n">edge</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">open_edge_names</span><span class="p">:</span>
            <span class="n">diag</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges</span> <span class="ow">and</span> <span class="n">open_edge_names</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">diag</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">)][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;fix_to&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">)]:</span>
                <span class="n">diag</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">)][</span><span class="s1">&#39;fix_to&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">)][</span><span class="s1">&#39;dim&#39;</span><span class="p">])</span>
                <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">)]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fix_to&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">diag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_node</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">((</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">[</span><span class="n">edge</span><span class="p">],</span> <span class="n">new_node</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="TensorNetwork.merge_edges"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.merge_edges">[docs]</a>    <span class="k">def</span> <span class="nf">merge_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">merge_to</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge a list of edges as one single edge by identification.</span>

<span class="sd">        :param edges: The list of edges to be merged into one.</span>
<span class="sd">        :type edges: :class:`List`</span>
<span class="sd">        :param merge_to: The name of the edge all the edges are merged to. If set to `None`, the merged edges will appear as `edges[0]`</span>
<span class="sd">        :type merge_to: hashable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">edge_name</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;dim&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)]:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">merge_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">merge_to</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">edges</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">merge_to</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">merge_to</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_dimension</span><span class="p">({</span><span class="n">merge_to</span><span class="p">:</span> <span class="n">dim</span><span class="p">})</span>
        <span class="n">nodes_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_name_from_edges_by_name</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge_name</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;fix_to&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fix_edge</span><span class="p">(</span><span class="n">merge_to</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)][</span><span class="s1">&#39;fix_to&#39;</span><span class="p">])</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">merge_to</span><span class="p">))</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">edge_name</span> <span class="o">!=</span> <span class="n">merge_to</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">remove_node</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">))</span>
            <span class="c1"># replace occurrence of edge_name by merge_to</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)][</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="o">=</span>\
                <span class="p">[</span><span class="n">merge_to</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edges</span>
                    <span class="k">else</span> <span class="n">i</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)][</span><span class="s1">&#39;edges&#39;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span> <span class="o">=</span>\
            <span class="p">[</span><span class="n">merge_to</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edges</span>
                <span class="k">else</span> <span class="n">i</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_signature</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">merge_to</span></div>

<div class="viewcode-block" id="TensorNetwork.rewire"><a class="viewcode-back" href="../../../tensor_network.html#acqdp.tensor_network.TensorNetwork.rewire">[docs]</a>    <span class="k">def</span> <span class="nf">rewire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">,</span> <span class="n">leg</span><span class="p">,</span> <span class="n">rewire_to</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rewire an outgoing edge of a tensor node to another edge in the tensor network.</span>

<span class="sd">        :param node_name: Name of the tensor node for whom an outgoing edge is to be rewired.</span>
<span class="sd">        :type node_name: hashable</span>
<span class="sd">        :param leg: Index of the outgoing edge regarding the tensor node. Should be an integer ranging from `0` to rank(t) - 1, t being the corresponding tensor.</span>
<span class="sd">        :type leg: `int`</span>
<span class="sd">        :param rewire_to: The edge name in the tensor network to redirect the leg to. If `None`, it will be rewired to a newly created edge.</span>
<span class="sd">        :type rewire_to: hashable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)][</span><span class="s1">&#39;tensor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)][</span><span class="s1">&#39;tensor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">leg</span><span class="p">]</span>
        <span class="n">edge_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)][</span><span class="s1">&#39;edges&#39;</span><span class="p">][</span><span class="n">leg</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rewire_to</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_by_name</span><span class="p">:</span>
            <span class="n">rewire_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">rewire_to</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)][</span><span class="s1">&#39;edges&#39;</span><span class="p">][</span><span class="n">leg</span><span class="p">]</span> <span class="o">=</span> <span class="n">rewire_to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rewire_to</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">edge_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)][</span><span class="s1">&#39;edges&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_signature</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand all tensor network hierarchical structure in the tensor network. Specifically, when there is a tensor node in the tensor network which is a</span>
<span class="sd">        :class:`TensorNetwork` or a :class:`TensorView` object, the tensor nodes in the tensor node are lifted up to the current tensor network level with</span>
<span class="sd">        corresponding connections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.tensor_view</span> <span class="kn">import</span> <span class="n">TensorView</span>
        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">cm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span> <span class="o">&lt;</span> <span class="n">b</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_name</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">cmp_to_key</span><span class="p">(</span><span class="n">cm</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)][</span><span class="s1">&#39;tensor&#39;</span><span class="p">],</span> <span class="n">TensorView</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_node</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_name</span><span class="p">[</span><span class="n">node_name</span><span class="p">][</span><span class="s1">&#39;tensor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">recursive</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)][</span><span class="s1">&#39;tensor&#39;</span><span class="p">]),</span> <span class="n">TensorNetwork</span><span class="p">):</span>
                <span class="n">pop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_node</span><span class="p">(</span><span class="n">node_name</span><span class="p">)</span>
                <span class="n">tsr</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="s1">&#39;tensor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">tsr</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">connection</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span>
                <span class="n">tsr</span><span class="o">.</span><span class="n">add_attribute_to_names</span><span class="p">(</span><span class="n">node_name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">tsr</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">tsr</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
                <span class="n">open_edges</span> <span class="o">=</span> <span class="n">tsr</span><span class="o">.</span><span class="n">open_edges</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">connection</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">open_edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">open_edges</span><span class="p">))])</span>
                <span class="k">for</span> <span class="n">ls</span> <span class="ow">in</span> <span class="n">networkx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
                    <span class="n">merge_to</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">connection</span><span class="p">)))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">merge_edges</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ls</span><span class="p">),</span> <span class="n">merge_to</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_signature</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">subtn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">open_edges</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed_edges_by_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_name_from_edges_by_name</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Illegal sub tensor network </span><span class="si">{</span><span class="n">nodes</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed_edges_by_name_from_nodes_by_name</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">edges</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">closed_edges_by_name_from_nodes_by_name</span><span class="p">(</span><span class="n">nodes</span><span class="p">)),</span>\
                    <span class="s2">&quot;Illegal sub tensor network&quot;</span>
        <span class="n">all_open_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_by_name_from_nodes_by_name</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;fix_to&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">)]]</span>
        <span class="k">if</span> <span class="n">open_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">open_edges</span> <span class="o">=</span> <span class="n">all_open_edges</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">open_edges</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_open_edges</span><span class="p">)),</span> <span class="s2">&quot;Illegal sub tensor network&quot;</span>

        <span class="n">stn</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">(</span><span class="n">open_edges</span><span class="o">=</span><span class="n">open_edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">stn</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)][</span><span class="s1">&#39;edges&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_name</span><span class="p">)][</span><span class="s1">&#39;tensor&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">)]:</span>
                <span class="n">stn</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">)][</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">)][</span><span class="n">e</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">stn</span>

    <span class="k">def</span> <span class="nf">encapsulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">open_edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">stn_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">stn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtn</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">open_edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_node</span><span class="p">(</span><span class="n">node_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge_name</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">])</span>
        <span class="n">stn_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">stn_name</span><span class="p">,</span> <span class="n">stn</span><span class="o">.</span><span class="n">open_edges</span><span class="p">,</span> <span class="n">stn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_signature</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">stn_name</span><span class="p">,</span> <span class="n">stn</span>

    <span class="k">def</span> <span class="nf">partial_contract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">open_edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">stn_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">stn_name</span><span class="p">,</span> <span class="n">stn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encapsulate</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">open_edges</span><span class="p">,</span> <span class="n">stn_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_node</span><span class="p">(</span><span class="n">stn_name</span><span class="p">,</span> <span class="n">stn</span><span class="o">.</span><span class="n">contract</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">flag</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">n0</span><span class="p">,</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">edge</span><span class="p">],</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">fix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">n0</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">n1</span><span class="p">]))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">])</span>
                    <span class="n">sz</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">n0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">n1</span><span class="p">]))</span>
                    <span class="n">new_sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">n0</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">n1</span><span class="p">]))</span> <span class="o">-</span> <span class="n">fix</span>
                    <span class="k">if</span> <span class="n">new_sz</span> <span class="o">&lt;=</span> <span class="n">sz</span><span class="p">:</span>
                        <span class="n">flag</span> <span class="o">=</span> <span class="n">recursive</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">encapsulate</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="n">n0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                    <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_expand_and_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">complete_delta</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tanner_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span> <span class="k">if</span> <span class="s1">&#39;fix_to&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="n">e</span><span class="p">)]]</span>
        <span class="n">edges</span> <span class="o">+=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed_edges_by_name</span> <span class="k">if</span> <span class="s1">&#39;fix_to&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="n">e</span><span class="p">)]]</span>
        <span class="n">x_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">edge_list</span>  <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
            <span class="n">x_nodes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">:</span>
                <span class="n">y_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">]</span>
        <span class="n">y_nodes</span> <span class="o">+=</span> <span class="n">edge_list</span>
        <span class="n">x_nodes</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(([</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_nodes</span><span class="p">),</span> <span class="p">(</span><span class="n">x_nodes</span><span class="p">,</span> <span class="n">y_nodes</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">subscripts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_name</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_by_name</span> <span class="k">if</span> <span class="s1">&#39;fix_to&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">)]]</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">lhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">opt_einsum</span><span class="o">.</span><span class="n">get_symbol</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)][</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]))</span>
            <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="mi">2</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">)][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">)][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)][</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">))</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">opt_einsum</span><span class="o">.</span><span class="n">get_symbol</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">shapes</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tn</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">tn</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tn</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">tn</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;tensor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tn</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;tensor&#39;</span><span class="p">]</span>
        <span class="n">tn</span><span class="o">.</span><span class="n">signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signature</span>
        <span class="k">return</span> <span class="n">tn</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">tn</span> <span class="o">=</span> <span class="n">TensorNetwork</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open_edges</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">tn</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tn</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">tn</span><span class="o">.</span><span class="n">update_node</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tn</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;tensor&#39;</span><span class="p">]))</span>
        <span class="n">tn</span><span class="o">.</span><span class="n">signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signature</span>
        <span class="k">return</span> <span class="n">tn</span>

    <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;tensor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;tensor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Alibaba Cloud Quantum Development Platform 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">acqdp.tensor_network.tensor_network</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Alibaba Quantum Laboratory.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>